/// <reference types="pixi.js" />
import { Graphics as PixiGraphics } from 'pixi.js';
import { BaseBlueprint } from '../../types/BaseBlueprint';
import { BasePropsType } from '../../types/BasePropsType';
import { IParentableBy } from '../../types/IParentableBy';
import { RenderableType } from '../../types/Renderable';
import { DisplayObjectPropsType } from '../../types/DisplayObjectPropsType';
import { _Root } from '../Root';
import { _Stage } from '../Stage';
export declare type _GraphicsParentTypes = _Graphics & _Stage & _Root;
export declare type GraphicsPropsType = {} & BasePropsType & DisplayObjectPropsType;
export declare class _Graphics extends BaseBlueprint<GraphicsPropsType> implements IParentableBy<_GraphicsParentTypes> {
    container: PixiGraphics;
    parent: _GraphicsParentTypes;
    prevProps: GraphicsPropsType;
    init(parent: _GraphicsParentTypes): void;
    updateBeforeChildren(props: GraphicsPropsType): void;
    updateAfterChildren(props: GraphicsPropsType): void;
    delete(): void;
}
export declare const Graphics: (props: {} & BasePropsType & {
    mask?: PixiGraphics | PIXI.Sprite;
    on?: (event: string, fn: Function, context?: any) => PIXI.utils.EventEmitter;
    off?: (event: string, fn: Function, context?: any) => PIXI.utils.EventEmitter;
    parent?: PIXI.Container;
    cacheAsBitmap?: boolean;
    name?: string;
    getGlobalPosition?: (point?: PIXI.Point, skipUpdate?: boolean) => PIXI.Point;
    accessible?: boolean;
    accessibleTitle?: string;
    accessibleHint?: string;
    tabIndex?: number;
    interactive?: boolean;
    buttonMode?: boolean;
    hitArea?: PIXI.IHitArea;
    interactiveChildren?: boolean;
    defaultCursor?: string;
    _isRightDown?: boolean;
    _isLeftDown?: boolean;
    transform?: PIXI.TransformBase;
    alpha?: number;
    visible?: boolean;
    renderable?: boolean;
    worldAlpha?: number;
    filterArea?: PIXI.Rectangle;
    x?: number;
    y?: number;
    worldTransform?: PIXI.Matrix;
    localTransform?: PIXI.Matrix;
    position?: PIXI.Point;
    scale?: PIXI.Point;
    pivot?: PIXI.Point;
    skew?: PIXI.Point;
    rotation?: number;
    worldVisible?: boolean;
    filters?: PIXI.Filter[];
    updateTransform?: () => void;
    getBounds?: (skipUpdate?: boolean, rect?: PIXI.Rectangle) => PIXI.Rectangle;
    getLocalBounds?: (rect?: PIXI.Rectangle) => PIXI.Rectangle;
    toGlobal?: (position: PIXI.Point, point?: PIXI.Point, skipUpdate?: boolean) => PIXI.Point;
    toLocal?: (position: PIXI.Point, from?: PIXI.DisplayObject, point?: PIXI.Point, skipUpdate?: boolean) => PIXI.Point;
    renderCanvas?: (renderer: PIXI.CanvasRenderer) => void;
    setParent?: (container: PIXI.Container) => PIXI.Container;
    setTransform?: (x?: number, y?: number, scaleX?: number, scaleY?: number, rotation?: number, skewX?: number, skewY?: number, pivotX?: number, pivotY?: number) => PIXI.DisplayObject;
    destroy?: () => void;
    once?: (event: string, fn: Function, context?: any) => PIXI.utils.EventEmitter;
    listeners?: (event: string) => Function[];
    emit?: (event: string, ...args: any[]) => boolean;
    removeListener?: (event: string, fn: Function, context?: any, once?: boolean) => PIXI.utils.EventEmitter;
    removeAllListeners?: (event: string) => PIXI.utils.EventEmitter;
    eventNames?: () => string[];
    addListener?: (event: string, fn: Function, context?: any) => PIXI.utils.EventEmitter;
}, children: RenderableType<BasePropsType, BaseBlueprint<BasePropsType> & IParentableBy<_Graphics>, _Graphics>[]) => RenderableType<{} & BasePropsType & {
    mask?: PixiGraphics | PIXI.Sprite;
    on?: (event: string, fn: Function, context?: any) => PIXI.utils.EventEmitter;
    off?: (event: string, fn: Function, context?: any) => PIXI.utils.EventEmitter;
    parent?: PIXI.Container;
    cacheAsBitmap?: boolean;
    name?: string;
    getGlobalPosition?: (point?: PIXI.Point, skipUpdate?: boolean) => PIXI.Point;
    accessible?: boolean;
    accessibleTitle?: string;
    accessibleHint?: string;
    tabIndex?: number;
    interactive?: boolean;
    buttonMode?: boolean;
    hitArea?: PIXI.IHitArea;
    interactiveChildren?: boolean;
    defaultCursor?: string;
    _isRightDown?: boolean;
    _isLeftDown?: boolean;
    transform?: PIXI.TransformBase;
    alpha?: number;
    visible?: boolean;
    renderable?: boolean;
    worldAlpha?: number;
    filterArea?: PIXI.Rectangle;
    x?: number;
    y?: number;
    worldTransform?: PIXI.Matrix;
    localTransform?: PIXI.Matrix;
    position?: PIXI.Point;
    scale?: PIXI.Point;
    pivot?: PIXI.Point;
    skew?: PIXI.Point;
    rotation?: number;
    worldVisible?: boolean;
    filters?: PIXI.Filter[];
    updateTransform?: () => void;
    getBounds?: (skipUpdate?: boolean, rect?: PIXI.Rectangle) => PIXI.Rectangle;
    getLocalBounds?: (rect?: PIXI.Rectangle) => PIXI.Rectangle;
    toGlobal?: (position: PIXI.Point, point?: PIXI.Point, skipUpdate?: boolean) => PIXI.Point;
    toLocal?: (position: PIXI.Point, from?: PIXI.DisplayObject, point?: PIXI.Point, skipUpdate?: boolean) => PIXI.Point;
    renderCanvas?: (renderer: PIXI.CanvasRenderer) => void;
    setParent?: (container: PIXI.Container) => PIXI.Container;
    setTransform?: (x?: number, y?: number, scaleX?: number, scaleY?: number, rotation?: number, skewX?: number, skewY?: number, pivotX?: number, pivotY?: number) => PIXI.DisplayObject;
    destroy?: () => void;
    once?: (event: string, fn: Function, context?: any) => PIXI.utils.EventEmitter;
    listeners?: (event: string) => Function[];
    emit?: (event: string, ...args: any[]) => boolean;
    removeListener?: (event: string, fn: Function, context?: any, once?: boolean) => PIXI.utils.EventEmitter;
    removeAllListeners?: (event: string) => PIXI.utils.EventEmitter;
    eventNames?: () => string[];
    addListener?: (event: string, fn: Function, context?: any) => PIXI.utils.EventEmitter;
}, _Graphics, _GraphicsParentTypes>;
export default Graphics;
export { RenderableType };
